# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T12:13:12+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Header, Path, Query
from pydantic import constr

from models import (
    BetDelayedResponse,
    BetHistoryResponse,
    BetPlacedResponse,
    BetSlipRequest,
    BetSlipResponse,
    CashInResponse,
    ComplexBetRequestBody,
    Errors,
    Exclude,
    Fields,
    FreeBet,
    Include,
    SingleBetRequestBody,
)

app = MCPProxy(
    contact={
        'email': 'platform@williamhill.com',
        'name': 'William Hill Labs',
        'url': 'http://developer.williamhill.com',
        'x-twitter': 'WilliamHill',
    },
    description='The Bets API methods are used to place single, multiple and complex bets and to retrieve a customer’s bet history. When retrieving a customer’s bet history you can organize the bets from the betting history in terms of date, bet type and whether the bet is settled or not. You can also specify what fields to be included/excluded or return a list of all default fields the method returns. <br /><br /> The Bets API will also generate a bet delay if you’re placing a single/multiple bet in-Play by creating a time margin to negate the effects of major changes to the market (for example, goals during a football match). Note that in version 2 of our APIs, Bets API contains the functionality of both Bets API v1 and the Betslips API v1.',
    title='Bets API',
    version='2.0.0',
    servers=[{'url': 'https://sandbox.whapi.com/v2/bets'}],
)


@app.post(
    '/bet/complex',
    description=""" Places a multiple or a complex bet. """,
    tags=['bet_management'],
)
def place_complex_bet(
    api_key: constr(pattern=r'^[a-zA-Z0-9]{19,50}$') = Header(..., alias='apiKey'),
    api_secret: constr(pattern=r'^[a-zA-Z0-9]{19,50}$') = Header(
        ..., alias='apiSecret'
    ),
    api_ticket: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9-]{39,100}$') = Header(
        ..., alias='apiTicket'
    ),
    fields: Optional[Fields] = None,
    include: Optional[Include] = None,
    exclude: Optional[Exclude] = None,
    body: ComplexBetRequestBody = ...,
):
    """
    Places a multiple or a complex bet.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/bet/single',
    description=""" Places a single bet. When placing a single bet using live inplay bets, the system might generate a bet delay to allow a time margin to negate the effects of major changes (for example, goals) to the market. Note that the amount of bet delay will vary by category and event type. A delayedBetId will be recieved that can be used to resubmit the bet. """,
    tags=['bet_management'],
)
def place_single_bet(
    api_key: constr(pattern=r'^[a-zA-Z0-9]{19,50}$') = Header(..., alias='apiKey'),
    api_secret: constr(pattern=r'^[a-zA-Z0-9]{19,50}$') = Header(
        ..., alias='apiSecret'
    ),
    api_ticket: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9-]{39,100}$') = Header(
        ..., alias='apiTicket'
    ),
    fields: Optional[Fields] = None,
    include: Optional[Include] = None,
    exclude: Optional[Exclude] = None,
    body: SingleBetRequestBody = ...,
):
    """
    Places a single bet
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/betslips',
    description=""" Organises the betslip when one or more selections are made. It returns a bet slip structure organised by betting opportunities. """,
    tags=['bet_management'],
)
def validate_betslip(
    api_key: constr(pattern=r'^[a-zA-Z0-9]{19,50}$') = Header(..., alias='apiKey'),
    api_secret: constr(pattern=r'^[a-zA-Z0-9]{19,50}$') = Header(
        ..., alias='apiSecret'
    ),
    expanded: Optional[str] = None,
    body: BetSlipRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/freebets',
    description=""" Retrieves the current free bets available for a customer. """,
    tags=['free_bet_management'],
)
def get_free_bets(
    api_key: constr(pattern=r'^[a-zA-Z0-9]{19,50}$') = Header(..., alias='apiKey'),
    api_secret: constr(pattern=r'^[a-zA-Z0-9]{19,50}$') = Header(
        ..., alias='apiSecret'
    ),
    api_ticket: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9-]{39,100}$') = Header(
        ..., alias='apiTicket'
    ),
    fields: Optional[Fields] = None,
    include: Optional[Include] = None,
    exclude: Optional[Exclude] = None,
):
    """
    Returns available free bets
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/history',
    description=""" Retrieves the customer’s bet history. Options are available to organise the history in terms of date, bet type and settled and unsettled bets. The maximum number of bets and bet history pages retrieved can also be set. """,
    tags=['bet_history_retrieval'],
)
def get_bet_history(
    api_key: constr(pattern=r'^[a-zA-Z0-9]{19,50}$') = Header(..., alias='apiKey'),
    api_secret: constr(pattern=r'^[a-zA-Z0-9]{19,50}$') = Header(
        ..., alias='apiSecret'
    ),
    api_ticket: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9-]{39,100}$') = Header(
        ..., alias='apiTicket'
    ),
    date_from: constr(
        pattern=r'^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})$'
    ) = Query(..., alias='dateFrom'),
    date_to: constr(
        pattern=r'^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})$'
    ) = Query(..., alias='dateTo'),
    fields: Optional[Fields] = None,
    include: Optional[Include] = None,
    exclude: Optional[Exclude] = None,
    page: Optional[float] = 1,
    page_size: Optional[float] = Query(100, alias='pageSize'),
    sort: Optional[str] = 'transDateTime,asc',
    settled: Optional[bool] = None,
):
    """
    Retrieves the customer’s bet history.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/{betId}/cashin',
    description=""" Allows a trusted application to cash in a bet (take a return on a bet) on behalf of the customer. If the customers monitor bets they can cash in a bet at any point before the event ends. """,
    tags=['bet_management'],
)
def cashin(
    api_key: constr(pattern=r'^[a-zA-Z0-9]{19,50}$') = Header(..., alias='apiKey'),
    api_secret: constr(pattern=r'^[a-zA-Z0-9]{19,50}$') = Header(
        ..., alias='apiSecret'
    ),
    api_ticket: constr(pattern=r'^[a-zA-Z][a-zA-Z0-9-]{39,100}$') = Header(
        ..., alias='apiTicket'
    ),
    bet_id: str = Path(..., alias='betId'),
    cash_in_value: float = Query(..., alias='cashInValue'),
    cashin_bet_delay_id: str = Query(..., alias='cashinBetDelayId'),
):
    """
    Allows a trusted application to cash in a bet (take a return on a bet) on behalf of the customer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
